-----------------------------------------------------------------------------------------------------------------
특수 멤버 함수(Special Member Function)

	기본 생성자(constructor)
	소멸자(destructor)
	복사 생성자 및 복사 할당(assignment)자
	이동 생성자 및 이동 할당자  	//C++11

	컴파일러가 스스로 작성할 수 있는 멤버 함수들
	객체의 생명주기와 복사/이동/소멸을 관리하는 데 핵심적인 역할

//C++98

복사 생성자는 
	복사 생성자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동 작성되며, 
	만일 이동 연산이 하나라도 선언되어 있으면 삭제된다.  복사할당연산의 경우도 마찬가지.
이동 연산들은 
	이동 연산들이나 복사 연선들, 소멸자가 
	명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성된다.
소멸자가 명시적으로 선언된 클래스에서 
	복사 연산들이 자동 작성되는 기능은 비 권장.

3의 법칙 (Rule Of Three)
	만일 복사 생성자와 복사 배정 연산자, 소멸자 중 하나라도 선언했다면 나머지도 전부 선언해야 한다.

-----------------------------------------------------------------------------------------------------------------
//C++11 : 이동 생성자, 이동 연산자 추가 ***

//이동 연산 자동 작성 조건
//      클래스에 어떤 복사 연산도 선언되어 있지 않다.
//      클래스에 어떤 이동 연산도 선언되어 있지 않다.
//      클래스에 소멸자가 선언되어 있지 않다.

-----------------------------------------------------------------------------------------------------------------

//특수 멤버 함수들의 자동 작성 조건을 숙지하라 ***

//특수 멤버 함수
//  컴파일러가 스스로 작성할 수 있는 멤버 함수들, 
//  즉 기본 생성자와 소멸자, 복사 연산들, 이동 연산들을 가리켜 특수멤버함수 라고 부른다.
// 
//  생성자 (Constructor) 
//  소멸자 (Destructor) 
//  복사 생성자 (Copy Constructor) 
//  복사 할당자 (Copy Assignment) 
//  이동 생성자 (Move Constructor) 
//  이동 할당자 (Move Assignment)

//기본 생성자  - 사용자 선언 생성자가 없는 경우에만 자동으로 작성
//소멸자        - 기반 클래스 소멸자가 가상일 때에만 가상이다, 소멸자가 기본적으로 noexcept (C++11)
//복사 생성자  - 비정적 데이터 멤버들을 멤버별로 복사 생성, 사용자 선언 복사 생성자가 없을 때에만 자동으로 작성, 
                    사용자 선언 복사 대입 연산자나 소멸자가 있는 클래스에서 이 함수가 자동 작성되는 기능은 비권장
//복사 대입 연산자 - 비정적 데이터 멤버들을 멤버별로 복사 대입, 사용자 선언 복사 연산자가 없을 때에만 자동, 
                    복사 생성자 만들면 같이 작성 권장
//이동 생성자  - 비정적 데이터 멤버의 멤버별 이동 생성, 사용자 선언 복사 연산들과 이동 연산들, 소멸자가 없을 때에만 작성된다
//이동 대입 연산자 - 비정적 데이터 멤버의 멤버별 이동 대입, 사용자 선언 복사 연산들과 이동 연산들, 소멸자가 없을 때에만 작성된다

-----------------------------------------------------------------------------------------------------------------
*** 자동생성 in C++11 총정리 *** 
-----------------------------------------------------------------------------------------------------------------

default 생성자 : 생성자 정의하면 자동 생성 안된다. C++ 98과 동일

소멸자 : 부모가 virtual이면 자식도 virtual로 자동 생성. 정의하면 자동생성 안된다. 여기까지 C++ 98, 
           C++ 11부터 바뀐점은 자동 생성된 소멸자가 noexcept로 만들어진다는 점. ***
           = delete 또는 사용자 정의 시 자동 생성되지 않음.

copy 연산자들 : 해당 함수가 선언되지 않았을 때, move 연산자들이 정의되지 않았을 때 자동 생성된다. ***
                    다른 copy연산자나, 소멸자가 있는 경우 자동 생성하는 것이 deprecated 되었다. 
                    비정적 멤버들에 대해서 해당 복사 연산자를 호출하는 방식으로 동작한다.

move 연산자들 : copy 연산자들, move 연산자들, 소멸자 모두가 정의되지 않았을 경우에만 자동 생성한다. ***
                    비정적 멤버들에 대해서 move 연산자를 호출하는 방식으로 동작한다.


특수 멤버함수가 템플릿 함수인 경우
          템플릿으로 짜여진 특수 멤버함수가 정의된 경우 자동생성을 방지하는 룰이 적용되지 않는다.

출처: https://ozt88.tistory.com/24

-----------------------------------------------------------------------------------------------------------------
% 자동 작성 여부를 이해하는 것은 Rule of Zero/Three/Five 개념과도 밀접하게 연결됩니다.

3의 법칙(Rule of Three)
      만일, 클래스 설계 시 복사 생성자와 복사 연산자, 소멸자 중 하나라도 선언했다면 모두 선언해야 한다.

5의 법칙(Rule of Five)
      C++11에는 소멸자, 복사 생성자, 복사 할당자, 이동 생성자, 이동 할당자
      다섯 중 하나라도 사용자가 직접 구현한다면, 나머지 넷도 모두 구현하는 것이 좋다. ***


//Rule of Five
//      기본 복사 생성자/대입 연산자는 **얕은 복사(shallow copy)**만 하기 때문에 문제가 발생합니다.
//      클래스가 자원을 직접 관리할 경우 다음 5개의 특별 멤버 함수를 직접 구현하거나 명시적으로 =default / =delete 해야 합니다:
//      STL 등 std::vector, std::string, std::optional 등은 내부적으로 Rule of Five를 잘 구현함.
//      만든 타입이 Rule of Five를 구현하면 STL 컨테이너에서도 안전하고 빠르게 작동함

// Rule of Zero
//      만약 자원 관리를 스마트 포인터(std::unique_ptr, std::shared_ptr) 같은 RAII 객체로 맡긴다면,
//      특별 함수들을 작성하지 않아도 되므로 Rule of Zero를 따르는 것이 더 바람직할 수 있습니다.

% 정리 ----------------------------------

Rule of Three	자원을 직접 관리 (복사 관련)
Rule of Five	자원을 직접 관리 + C++11 이상 (이동까지 포함)
Rule of Zero	자원을 스마트 포인터 등으로 관리할 때

% 실전 지침 ----------------------------

Rule of Zero
	자원 관리 (new, delete) 없이 STL이나 스마트 포인터만 사용하면, 직접 아무 것도 정의할 필요 없음.
Rule of Three
	자원 해제를 위해 소멸자, 복사 생성자, 복사 대입자를 정의해야 하면 셋 다 작성해야 함.
Rule of Five (C++11 이상)
	이동 시멘틱이 필요한 경우 복사 관련 3개 + 이동 생성자, 이동 대입자 모두 작성해야 안전.
