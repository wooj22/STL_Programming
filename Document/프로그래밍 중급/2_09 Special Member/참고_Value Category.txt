기존의 C에서 사용했던 Rvalue, Lvalue와는 다른 정의를 가지고 있다.

좌측값은 대입(assignment) 시에 왼쪽 혹은 오른쪽에 오는 식(expression)이고, 우측값은 대입 시에 오직 오른쪽에만 오는 식이다.


그러나 C++에서는 다음과 같의 정의를 하고 있다.

좌측값은 어떠한 메모리 위치를 가리키는데, & 연산자를 통해 그 위치를 참조할 수 있다. 우측값은 좌측값이 아닌 값들이다.


또한 C++11 부터, rvalue, lavalue 뿐만 아니라 prvalue, xvalue, glvalue라는 개념이 추가되었다.

lvalue : identity를 가지면서 move될 수 없는 표현식들
xvalue : identity를 가지면서 move될 수 있는 표현식들
prvalue : identity를 가지고있지 않으면서 move될 수 있는 표현식들
glvalue : identity를 가지고있는 표현식들(lvalue, xvlaue모두 glvalue 표현식)
rvalue : move될 수 있는 표현식들(prvalue, xvalue 모두 rvalue 표현식)
identity를 가지고 있지 않으면서 move될 수 없는것들

C++11에서는 값이 식별성을 가지고 있는 경우에 “identity를 가진다.”라고 표현한다. 
또, 값이 메모리에서 이동 될 수 있는 것을 “move될 숫 있다.”라고 표현한다.

Primary category

	xvalue
	lvalue
	prvalue

Mixed cateogry

	rvalue(xvalue + prvalue)
	glvalue(xvalue + lvalue)

------------------------------------------------------------------------------------------------------
lvalue는 식별자를 갖지만 이동 될수 없는 값 
	모든 변수, 함수, 전위증감 표현식, lvalue 참조, 문자열 리터럴 등
특징
	대입문의 좌측에 올 수 있다.
	&연산자로 값의 주소를 얻어올 수 있다.
	표현식이 끝나더라도 값이 살아있다.


static int a = 10;
int& foo() {  a++;  return a;  }
int foo2() {  return a;  }

//좌측값 (Lvalue)
int main(){
    int a = 10,b=10,c=10;
    int *j = &a;    //참조 가능하기 때문에 a는 좌측값(Lvalue)
    foo() = 43;    //foo()는 좌측값(Lvalue)
    int *ptr1 = &foo();    //&foo()가능하기 때문에 좌측값(Lvalue)
    ++a;                 //a는 lvalue, pre-increasement, pre-decreasement
    int c[4];
    std::cout << c[1] << std::endl;     //c[1]도 lvalue
    a ? b : c;      // a ? b : c의 반환값은 b 또는 c이므로 lvalue
}
------------------------------------------------------------------------------------------------------
xvalue
	identity를 가지면서 move될 수 있는 표현식들
특징
	컴파일러만 사용하는 객체 이기 때문에 &연산자가 허용되지 않는다.
	표현식이 끝났을 때 사라진다.
------------------------------------------------------------------------------------------------------
prvalue
	identity를 가지고있지 않으면서 move될 수 있는 표현식들
특징
	대입문의 우측에 올 수 있다.
	주소가 없다.

{
    int a = 10;
    int b = 20;
    a++;
    a+b;
    if(a < b){      //a<b의 결과값 bool은 prvalue
    }
}