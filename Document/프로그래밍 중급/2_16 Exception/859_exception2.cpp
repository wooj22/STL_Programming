//미처리예외

//	throw로 예외를 던졌는데 받을 catch 블록이 없거나 있더라도 예외 타입이 맞지 않다면 미처리 예외가 된다.
//	아무도 처리하지 않는 예외는 termivate 함수가 처리하며, 내부적으로 abort 함수를 호출하여 프로그램을 '강제 종료'한다.
//	강제종료가 프로그램에 좋지 않은 것 같지만, 개발 중에 문제를 분명히 알리는 것이 차라리 낫다.
// 
//	미처리 예외를 직접 처리하고 싶다면 다음 함수로 미처리 예외 핸들러를 등록한다.
//	인수로 void func(void) 타입(terminate_handler)의 함수 포인터를 전달하면,
//	이후부터 미처리 예외가 발생할때 이 함수가 호출된다.

#include <iostream>
#include <exception>

using namespace std;

void myterm()
{
	puts("처리되지 않은 예외 발생");
	exit(-1);
}

int main()
{
	set_terminate(myterm);		//애플리케이션을 종료하기 전에 terminate로 프로그램의 다른 함수를 호출한다.

	try
	{
		throw 1;
	}
	catch (char* m)
	{

	}
	//catch (...)
	//{
	//	puts("뭔지는 모르겠지만 일단 예외가 발생했음");
	//}
}

//terminate는 전역적인 예외 핸들러인데 비해, catch(...)는 국지적인 미처리 예외 핸들러이다.

//main 문에서의 return(0) 은 exit(0)과 같은 의미를 가진다. 
//즉, 프로그램이 모두 실행되고 정상 종료되는 것을 의미할 땐 exit(0)을 사용한다.



//컴파일러는 등장하는 순서대로 catch 블록을 점검하여 타입이 일치하는 핸들러를 찾는다. ----------------------

//catch 블록의 올바른 배치
/*
	try {}
	catch (int)
	catch (char*)
	catch (exception)
	catch (...)
*/


//예외 객체의 타입 점검  ------------------------------------------------------------------------------

//	정확한 예외 처리를 위해 예외 객체의 타입 점검이 굉장히 엄격하다.
//	컴파일러는 예외 객체 타입으로 catch 블록은 선택하는데 타입 점검이 엄격하기 때문에 
//	암시적 변환은 고려하지 않는다. ***
//
//예외적으로 ***
//	void* 타입을 받는 핸들러는 임의의 포인터 타입을 받을 수 있고 
//	부모 타입의 포인터를 받는 핸들러는 자식타입의 객체를 받을 수 있다.


 
//함수의 예외 지정 -----------------------------------------------------------------------------------
//	함수의 원형 뒤쪽에 함수 실행 중에 발생 가능한 예외의 목록을 지정할 수 있다.
/*
//인수 목록 다음에 throw(예외 목록) 형식으로 괄호 안에 예외 타입을 적되 여러 개일 경우 콤마로 나열한다.

	void sub1(int a, int d) throw(char*)
	void sub2(int a, int d) throw(char*, int)

//예외를 던지지 않는 함수는 throw()만 적어 괄호 안을 비워둔다. 
//throw 지정이 없는 함수는 임의의 예외를 던질 수 있다는 뜻이다.
//다음 두 함수는 원형은 같지만 예외 지정은 완전히 다르다.

	void sub3(int a, int d) throw()
	void sub4(int a, int d)

*/

//예외 처리의 한계 ---------------------------------------------------------------------------------

//예외 처리 기능을 사용하면 여기저기 필요한 코드가 삽입되어 프로그램은 커지고 성능은 떨어진다.
//특히 스택 되감기는 호출된 모든 함수의 스택을 강제 정리하는 대공사여서 속도가 심하게 떨어진다.
//이런 상황이 자주 발생하지 않지만 어쨌든 필요한 코드를 모두 생성해야 하니 프로그램이 비대해질 수 밖에 없다.

//스택 되감기는 지역 변수를 깔끔하게 정리하고 객체의 파괴자도 정상적으로 잘 호출된다. 
//호출 단계가 아무리 깊어도 스택의 항상성을 정확히 유지해준다. 
//그러나 이는 스택 기반의 변수에 한정될 뿐이며, 동적으로 할당한 메모리는 정리하지 못하는 한계가 있다.

/*
	#include <iostream>
	using namespace std;

	class SomeClass {};

	void calc() throw(int)
	{
		SomeClass obj;
		char* p = new char[1000];
		if (true ) throw 1;			//예외발생
		delete[] p;					//
	}

	int main()
	{
		try	{
			calc();
		}
		catch (int)
		{
			puts("정수형 예외 발생");
		}
	}
*/

//예외 처리 구문은 다른 기능과 충돌을 일으키기도 하는데, 대표적으로 템플릿과 잘 어울리지 않는다.

//멀티 스레드 환경에서도 여러가지 문제를 야기하는데, 
//	C++의 예외 처리 기능 자체는 멀티 스레드를 고려하여 동기적으로 설계되어 있지만 
//	실제 적용시에는 여러 가지 복잡한 규칙을 따라야하고 주의사항이 많아 예외를 매끈하게 처리하기 쉽지 않다.

//예외 처리 발생시 적당한 핸들러를 찾아 점프하여 예외를 처리할 뿐 예외를 복구할 수는 없다.
//	catch로 점프해버리면 다시 try블록으로 돌아갈 방법이 없다.

//예외 처리 기능은 라이브러리 내의 깊은 호출 단계에서 발생한 예외까지고 잡아낸다는 점에서 훌륭하지만 
//반대급부가 있으므로 꼭 필요한 때만 사용하는 것이 좋다. ***
