//C++은 세 가지 기본 타입의 메모리 할당을 지원한다.

//자동 메모리 할당(auto memory allocation)은
//		함수 매개 변수와 지역 변수에 대해 발생한다.
//		이러한 타입의 변수에 대한 메모리는 관련 블록을 입력할 때 할당되고, 블록을 종료할 때 필요에 따라 여러 번 해제된다.

//정적 메모리 할당(static memory allocation)은
//		정적 변수와 전역변수에 대해 발생한다.
//		이러한 타입의 변수에 대한 메모리는 프로그램이 실행될 때 한 번 할당되며, 프로그램 수명 내내 지속한다.

//동적 메모리 할당(dynamic memory allocation)은
//		프로그램 실행 중에 필요한 메모리를 운영체제에 요청하는 방법이다.


//정적 및 자동 메모리 할당의 한계
// 
//		메모리 할당 및 해제가 자동으로 수행된다. (변수가 인스턴스화 / 제거되는 경우)
//		변수 / 배열의 크기는 컴파일 타임에 알아야 한다.
//
//		낭비되는 메모리가 많다
//		스택(stack)이라는 메모리 영역에 할당
//		인위적인 한계 및 또는 배열 오버플로가 발생할 수 있다
//
//동적 메모리 할당(dynamic memory allocation) 으로 해결.

#include <iostream>

int main()
{
	//운영 체제에서 정수값의 메모리를 요청한다. 
	//new 연산자는 해당 메모리를 사용하여 객체를 만든 다음 할당된 메모리의 주소가 포함된 포인터를 반환한다.
	int* ptr = new int; 
		
	//포인터를 역참조(dereference)하여 메모리에 접근할 수 있다.
	*ptr = 7;	

	//방금 할당된 메모리의 주소를 유지하는 포인터가 없으면 할당된 메모리에 접근할 수 없다.

	//메모리를 해제하여 재사용할 수 있도록 C++에 명시적으로 알려야 한다.
	delete ptr;

	//delete 연산자는 실제로 아무것도 삭제하지 않는다. ***
	//단순히 가리키는 메모리를 다신 운영 체제로 반환한다.
	 
	//동적으로 할당된 메모리를 가리키지 않는 포인터를 삭제하면 에러가 발생할 수 있다. ***
	delete ptr;		// 운영체제에 돌려준 공간 침범 //여러번 delete 하면 안됨

	return 0;
}

//댕글링 포인터 (Dangling pointers) ------------------------------------------------------------
//
//	C++은 할당되지 않은 메모리의 내용이나 삭제되는 포인터의 값에 대해서는 보장하지 않는다.
// 
//	운영 체제에 반환되는 메모리에는 
//  반환되기 전의 값과 같은 값이 포함되며, 포인터는 현재 할당 해제된 메모리를 가리킨다.
//	할당이 해제된 메모리를 가리키는 포인터를 '댕글링 포인터'(dangling pointer)라고 한다.
// 
//	댕글링 포인터를 역참조하거나 삭제하면 정의되지 않은 동작이 발생한다.
//
//	먼저, 여러 포인터가 같은 동적 메모리를 가리키는 것을 피하자. ***
//	둘째, 포인터를 삭제할 때 포인터를 0 또는 nullptr로 설정하자. ***

// Null pointers -----------------------------------------------------------------------------
 
//	동적 메모리 할당과 관련하여 널 포인터는 
//	기본적으로 "이 포인터에 메모리가 할당되지 않았다" 를 의미한다.
// 
//	이렇게 하면 조건부로 메모리를 할당하는 작업을 할 수 있다. ***
//		if (!ptr) ptr = new int;
 
//	널 포인터는 삭제되지 않는다. 따라서 다음과 같이 할 필요가 없다. ***
//		if (ptr) delete ptr;
//	대신, 다음과 같이 작업하면 된다.
//		delete ptr;					//ptr 이 널이 된 것은 아니다.
// 
//	ptr이 
//		nullptr 이 아닌 경우, 동적으로 할당된 변수가 삭제된다. 
//		만약 nullptr 이라면, 아무 일도 일어나지 않는다.
// 
//		ptr = nullptr;
//		delete ptr;


// 메모리 누수 (Memory leak) -----------------------------------------------------------------
//		delete 안함, 주소상실, 중복할당 등의 경우 메모리 누수 발생

	{
		int* ptr = new int;		// delete 안함 //new int 영역은 미아
	}

	{
		int value = 5;
		int* ptr = new int;		
		ptr = &value;			// 주소상실 //old address lost, memory leak results
	}
	
	{
		int* ptr = new int;		// allocate memory
		cout << ptr << endl;
		ptr = new int;			// 재할당 //기존의 new int 영역은 미아가 되버린다
	}

	int* ptr = nullptr;
	for (size_t i = 0; i < 10; i++)	{
		ptr = new int;	*ptr = 1;	// 재할당
	}
	delete ptr;

// Bouble Free ------------------------------------------------------

	int* ptr = nullptr;
	ptr = new int;
	delete ptr;
	delete ptr;		//
