//가상함수 테이블 //vtable

#include <iostream>
using namespace std;

class AAA {
	int a;
public:
	virtual void Func1() { cout << "AAA::Func1" << endl; }
	virtual void Func2() { cout << "AAA::Func2" << endl; }
};

class BBB : public AAA {
	int b;
public:
	virtual void Func1() { cout << "BBB::Func1" << endl; }
	void Func3() { cout << "BBB::Func3" << endl; }
};

int main()
{
	AAA* ap = new AAA();
	ap->Func1();					//F9 _vfptr			//디버깅으로 확인

	BBB* bp = new BBB();
	bp->Func1();					//F9 _vfptr

}

//가상 함수 테이블(vtable)은 '함수 포인터 배열'이며,
//이 포인터를 따라가면 가상 함수로 선언된 멤버 함수들의 주소에 배열 형태로 접근할 수 있다.
//즉, 가상 함수 테이블이 실제 호출되어야 할 함수의 위치를 저장하고 있다.

//AAA 클래스의 가상테이블		AAA::Func1, AAA::Func2
//BBB 클래스의 가상테이블		BBB::Func1, AAA::Func2 //AAA::Func1 는 없음


//가상함수테이블은 언제 만들까? --------------------------------------------------------------
// 
//  가상함수테이블은 가상함수가 있는 클래스마다 1개씩만 생성된다. ***
//  객체를 여러개 생성된다고 여러개 만들지 않는다.
// 
//  vftable 은 컴파일러가 해당 소스 코드 파일을 컴파일하면서 알아낸 정보를 바탕으로 
//  PE 파일의 Section에 미리 기록해 둡니다. (key-value : 이름과 주소)
//  instance 별로 생성되는 것이 아닌, 클래스 별로 생성된다
 
//virtual 선언하면 클래스 사이즈가 증가한다. (가상테이블의 포인터 사이즈) ***
// 
//  Virtual Table 이 생성이 되고 이를 '가리키는 pointer'가 객체의 메모리 영역에 생기기 때문이다. 
//  객체의 가상 포인터(v-pointer)를 따라가면, 클래스의 가상 테이블(v-Table)이고, 여기에서 함수 선택.
//  객체의 시작 주소값(v-pointer) -> vtable + 0 -> func() 이런식의 흐름

//가상 함수 테이블의 크기
//
//  가상 함수 테이블의 크기는 해당 클래스에 정의된 가상함수 개수에 비례한다.
//  여기서 정의된 가상함수란 상위 클래스에 정의된 가상함수도 포함한다.
//  따라서, 재정의 하지 않고 가상 함수를 호출하면, 상위 클래스에 정의된 가상 함수가 호출된다. 


//Dynamic Polymorphism (동적 다형성) ------------------------------------------------------
// 
//	Polymorphism을 Compile-time이 아닌 Run-time에 얻는 것을 의미한다 
// 
//	멤버 함수는 일반 함수와 동일하게 "code"영역에 저장이 되게 된다. 
//	객체가 생성될 때마다 매번 멤버 함수가 할당이 되면 비효율적이기 때문에 "code"영역에 저장하고 공유를 한다.
// 
//	Virtual Function을 Override 함으로써 동적 다형성을 구현할 수 있다.
//	즉, 런타임에 가상테이블을 참조하여, 선언된 형식이 아닌 오버라이드된 함수를 찾아 준다.

//정적바인딩, 동적바인딩 ------------------------------------------------------------------
// 
//	정적바인딩: 컴파일 시에 메모리를 할당(바인드)한다. 일반함수, 일반변수 할당
//	동적바인딩 : 실행 시에 메모리를 할당(바인드)한다. 가상함수, 변수 동적 할당
