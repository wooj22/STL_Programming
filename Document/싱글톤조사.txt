과제 : 싱글톤 디자인 패턴 조사
이름 : 양우정

* 싱글톤(Singletone)
 - 하나의 클래스에 대해 하나의 객체만 생성하도록 제어하는 디자인 패턴으로, 유일한 인스턴스에 대한 전역 접근을 제공한다.

* 싱글톤 원리
 - 생성자를 private으로 보호하여 외부에서의 객체 생성을 막는다.
 - 하나의 객체만을 유지하기 위해 instance를 static으로 생성한다. static 변수는 프로그램 종료시까지 유지되며, 해당 클래스의 모든 객체들이 공유하기 때문에 단 하나만 유일하게 존재한다.
 - 복자 생성자와 대입 연산자를 삭제하여 외부에서의 복사를 방지한다.
 - 외부에서 instance를 get하기 위한 public return 함수만들어 외부에서 객체에 접근하여 사용할 수 있도록 한다.

* 싱글톤 장단점
 - 장점 
   프로그램 전역에서 하나의 인스턴스를 공유할 수 있어 자원 관리와 접근이 편리하다.
 - 단점
   프로그램 종료 시점까지 살아있는 경우가 많으며 삭제 타이밍을 명확하게 제어하기가 어렵다.

* 멀티스테드 안정성 이슈 '경쟁조건(Race condition)과 thread-safe'
 - 문제 상황) 동시에 여러 스레드가 싱글톤을 생성하려는 경우
   static instacne를 멤버 변수로 두고 GetInstacne()함수로 instacne의 null여부를 검사하여 retrun하는 경우, 멀티스레드 환경에서 동시에 GetInstacne()가 호출되었다면 인스턴스를 두번 이상 생성될 수 있는 위험이 있다. 

  - 해결 ) C++11 이상에서는 '정적 지역 변수'의 초기화가 thread-safe가 보장되어 함수 내에서 정적 지역 변수로 instance를 생성하는 경우에는 여러 스레드가 진입하더라도 instance는 한번만 안전하게 초기화 된다. 하지만 instance를 정적 지역 변수가 아닌 멤버 변수로 두는 경우에는 여전히 Race condition문제가 발생하여 이 방법은 사용하지 않거나 추가적으로 rock을 거는 방식을 사용해야한다.

 Q. static instace 멤버 변수가 여전히 위험한 이유 ('지역'변수만 thread-safe되도록 업데이트 한 이유)
 - C++11에서 "왜 지역 변수만 thread safe 초기화를 보장하였을까? 이 이유는 단순 정책이 아니라 실행 과정에 차이가 있기 때문이다. 정적 지역 변수는 컴파일러가 완전히 통제할 수 있는 초기화 지점이 명확한 반면, 정적 멤버 변수는 초기화가 프로그램 전역 또는 여러 컴파일 단위에 걸쳐 분산되기 때문이다. 더 정확하게 말하자면 함수의 지역 변수로 두는경우 instacne의 생성 시점이 함수의 최조 호출 시점이지만, 멤버 변수로 두는 경우 프로그램 시작시 자동으로 초기화 되기 때문에 시점이 불명확하다. 이때문에 싱글톤 패턴을 구현하는 경우 instace는 지역 변수로 선언하는 방식을 채택하는 것이 낫다.