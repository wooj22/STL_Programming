// 포인터 참조와 const
// const가 앞에 붙으면 데이터 const
// const가 뒤에 붙으면 포인터 const 이다.

#include <iostream>
using namespace std;

int main(void)
{
	int a = 10;
	int b = 20;

	// 포인터 참조
	{
		int* ptr = &a;
		int*& ptr1_ref = ptr;

		*ptr = 100;			// 데이터 값 변경 가능
		ptr = &b;			// 포인터 값 변경 가능

		cout << "a : " << a << endl;
		cout << "b : " << b << endl;
		cout << "ptr : " << *ptr << endl;
	}
	
	// const 참조
	// 주의할점은 참조변수의 const는 포인터의 cosnt와 동일해야한다.
	{
		// [ const T& ] : 데이터가 const
		// T에 const가 붙었으니 참조가 가리키는 데이터의 변경이 불가능하다
		{
			const int* ptr = new int(5);
			const int*& ptr_ref = ptr;

			ptr_ref = &b;	    // 포인터 값 변경 가능
			*ptr_ref = 200;		// 데이터 값 변경 불가능
		}

		// [ T const& ] : 포인터가 const
		// 참조에 const가 붙었으니 참조 대상의 변경이 불가능하다.
		{
			int* const ptr = new int(5);
			int* const& ptr_ref = ptr;

			ptr_ref = &b;	    // 포인터 값 변경 불가능
			*ptr_ref = 200;		// 데이터 값 변경 가능	
		}

		// [ const T const & ] : 데이터와 포인터 모두 cosnt
		{
			const int* const ptr = &a;
			const int* const& ptr_ref = ptr;

			ptr_ref = &b;		// 포인터 값 변경 불가능
			*ptr_ref = 200;		// 데이터 값 변경 불가능
		}
	}
}

// 참조 자료
// 참조형 타입의 장점은 메모리의 소유가 어디인지를 명확히 하는데 있다.
//		참조로 함수에 넘기게 되면, 해제 할수가 없다.
//		포인터를 이용하다가 엉뚱한 메모리를 수정하는 불상사를 미연에 방지
//		참조는 포인터에 비해 유연하지는 않지만 안정성을 보장해 준다.

/*
//포인터와 참조자의 차이점

포인터와 참조자는 C++에서 변수를 가리키거나 참조하는 데 사용되는 두 가지 주요 개념입니다.
그러나 두 개념 간에 몇 가지 기본적인 차이점이 있습니다 :

포인터(Pointer) :
	포인터는 메모리 주소를 저장하는 변수입니다.
	변수를 가리키는 데 사용됩니다.
	선언 시에 주소를 할당할 필요가 없고, 나중에 다른 주소를 할당할 수 있습니다.
	포인터는 변수를 변경할 수 있습니다.
	메모리를 차지하며, * 연산자를 사용하여 변수를 변경합니다.

참조자(Reference) :
	참조자는 변수의 별칭(alias)입니다.
	변수를 참조하는 데 사용됩니다.
	반드시 처음에 변수를 할당해야 하며, 나중에 변경할 수 없습니다.
	참조자는 메모리를 차지하지 않습니다.
	변수의 값을 그대로 대체합니다.
	변수를 변경할 수 없습니다.

간단히 말하면, 포인터는 메모리 주소를 직접 다루는 반면, 참조자는 변수의 별칭으로 동작합니다.
레퍼런스는 포인터를 위험하게 사용하는 경우를 방지하기 위해 안전하게 사용할 수 있도록 만들어진 개념입니다
*/


// 가능하면 참조자를 쓰고, 어쩔 수 없다면 포인터를 써라 ***
// 
// 매개변수에 NULL 포인터를 넘겨주는 것 or 
// 리턴값으로 NULL 포인터를 반환하는 것이 허용될 경우, 포인터를 사용해야 한다.

// 포인터의 경우     - nullptr 인지 여부를 확인하고 사용해야 한다. ***
// 참조 사용의 경우  - 참조하는 대상이 존재하는지 여부를 주의해야 한다. ***
