
/*
	[ 포인터 const 참조 ]

	const가 앞에 붙으면 : 포인터가 "가리키는 데이터"가 const
	const가 뒤에 붙으면 : "포인터 자체(주소)"가 const

	ex )
		const int* p         -> *p 읽기만 가능 (데이터 const)
		int* const p         -> p = 다른 주소 불가 (포인터 const)
		const int* const p   -> 데이터도 const, 포인터도 const


    ! 핵심 규칙 : "참조 타입의 '가리키는 타입'(T 또는 const T)은
                  반드시 원본 포인터의 가리키는 타입과 동일해야 한다."
        int* ptr;
        const int*& ref = ptr;     // 불가능

    왜 불가능한가?
		int*    →  const int*   로 타입이 바뀌면서 참조하는 것이 위험하기 때문.

		ref가 const int*& 로 선언되면, ref는 "const int* 를 참조한다"고 믿는다.
		그런데 실제로 ref는 int* 를 참조하고 있으므로

		    ref = 다른 const int*;   // ref는 const int* 이므로 이런 코드가 가능해짐

		이렇게 되면 결국 ptr도 const int* 로 바뀌어버리고,
		한 단계 더 가면 "원래 const가 아니었던 int"가 const로 포장되어
		나중에 const를 제거하는 위험한 상황이 생긴다.
		즉, C++은 "가리키는 타입을 const로 승격시키면서 참조"하는 일을
		컴파일 단계에서 차단한다.

	>> 포인터 참조변수는 굳이 쓰지 말고, 
		그냥 포인터는 포인터로 참조해라~!
*/


#include <iostream>
using namespace std;

int main(void)
{
	int a = 10;
	int b = 20;

	// 포인터 참조
	{
		int* ptr = &a;
		int*& ptr1_ref = ptr;

		*ptr = 100;			// 데이터 값 변경 가능
		ptr = &b;			// 포인터 값 변경 가능

		cout << "a : " << a << endl;
		cout << "b : " << b << endl;
		cout << "ptr : " << *ptr << endl;
	}
	
	// const 참조
	{
		// [ const T*& ] : 가리키는 타입이 const T인 포인터에 대한 참조
		// T에 const가 붙었으니 참조가 가리키는 데이터의 변경이 불가능하다
		// 참조 타입의 '가리키는 타입'(const T)은 원본 포인터의 타입과 동일해야 한다.
		{
			const int* ptr = new int(5);
			const int*& ptr_ref = ptr;

			ptr_ref = &b;	    // 포인터 값 변경 가능
			*ptr_ref = 200;		// 데이터 값 변경 불가능
		}

		// [ T* const& ] : 포인터가 const
		// 참조에 const가 붙었으니 참조 대상의 변경이 불가능하다.
		{
			int* ptr = new int(5);
			int* const& ptr_ref = ptr;

			ptr_ref = &b;	    // 포인터 값 변경 불가능
			*ptr_ref = 200;		// 데이터 값 변경 가능	
		}

		// [ const T* const & ] : 데이터와 포인터 모두 cosnt
		{
			const int* const ptr = &a;
			const int* const& ptr_ref = ptr;

			ptr_ref = &b;		// 포인터 값 변경 불가능
			*ptr_ref = 200;		// 데이터 값 변경 불가능
		}
	}
}

// 참조 자료
// 참조형 타입의 장점은 메모리의 소유가 어디인지를 명확히 하는데 있다.
//		참조로 함수에 넘기게 되면, 해제 할수가 없다.
//		포인터를 이용하다가 엉뚱한 메모리를 수정하는 불상사를 미연에 방지
//		참조는 포인터에 비해 유연하지는 않지만 안정성을 보장해 준다.

/*
//포인터와 참조자의 차이점

포인터와 참조자는 C++에서 변수를 가리키거나 참조하는 데 사용되는 두 가지 주요 개념입니다.
그러나 두 개념 간에 몇 가지 기본적인 차이점이 있습니다 :

포인터(Pointer) :
	포인터는 메모리 주소를 저장하는 변수입니다.
	변수를 가리키는 데 사용됩니다.
	선언 시에 주소를 할당할 필요가 없고, 나중에 다른 주소를 할당할 수 있습니다.
	포인터는 변수를 변경할 수 있습니다.
	메모리를 차지하며, * 연산자를 사용하여 변수를 변경합니다.

참조자(Reference) :
	참조자는 변수의 별칭(alias)입니다.
	변수를 참조하는 데 사용됩니다.
	반드시 처음에 변수를 할당해야 하며, 나중에 변경할 수 없습니다.
	참조자는 메모리를 차지하지 않습니다.
	변수의 값을 그대로 대체합니다.
	변수를 변경할 수 없습니다.

간단히 말하면, 포인터는 메모리 주소를 직접 다루는 반면, 참조자는 변수의 별칭으로 동작합니다.
레퍼런스는 포인터를 위험하게 사용하는 경우를 방지하기 위해 안전하게 사용할 수 있도록 만들어진 개념입니다
*/


// 가능하면 참조자를 쓰고, 어쩔 수 없다면 포인터를 써라 ***
// 
// 매개변수에 NULL 포인터를 넘겨주는 것 or 
// 리턴값으로 NULL 포인터를 반환하는 것이 허용될 경우, 포인터를 사용해야 한다.

// 포인터의 경우     - nullptr 인지 여부를 확인하고 사용해야 한다. ***
// 참조 사용의 경우  - 참조하는 대상이 존재하는지 여부를 주의해야 한다. ***
